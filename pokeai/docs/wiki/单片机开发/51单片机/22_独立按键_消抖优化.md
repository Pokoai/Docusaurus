---
position: 3
---

> 实际做项目开发的时候，程序量往往很大，各种状态值也很多， while(1) 这个主循环要不停的扫描各种状态值是否有发生变化，及时的进行任务调度，如果程序中间加了这种 delay 延时操作后，很可能某一事件发生了，但是我们程序还在进行 delay 延时操作中，当这个事件发生完了，程序还在 delay 操作中，当我们 delay 完事再去检查的时候，已经晚了，已经检测不到那个事件了。为了避免这种情况的发生，我们要尽量缩短 while(1) 循环一次所用的时间，而需要进行长时间延时的操作，必须想其它的办法来处理。

> 启用一个定时中断，每 2ms 进一次中断，扫描一次按键状态并且存储起来，连续扫描 8 次后，看看这连续 8 次的按键状态是否是一致的。8 次按键的时间大概是 16ms，这 16ms 内如果按键状态一直保持一致，那就可以确定现在按键处于稳定的阶段，而非处于抖动的阶段。

```c

// 头文件
#include <reg52.h>

// 类型重定义
typedef unsigned char u8;
typedef unsigned int u16;

// 管脚定义
sbit key1 = P2^0;  

// 全局变量
bit keySta = 0;  // 初值为未按下


// 定时器初始化
void timer_init()
{
    TMOD = 0x01;
    TH1 = 0xF8;  // 2ms
    TL1 = 0xCD;
    EA = 1;
    ET1 = 1;
    TR1 = 1;
}

// 定时器中断服务函数
// 在这里进行按键扫描
void timer1_isr() interrupt 3
{
    static u8 keyBuf = 0xFF;  // 存储8次扫描状态

    TH1 = 0xF8;
    TL1 = 0xCD; 

    keyBuf = (keyBuf << 1) | key1;  // 存入当前扫描值
    // 连续 8 次扫描均为 0，说明按键已按下
    if ( keyBuf == 0x00 ) {
        keySta = 1;
    } else if ( keykBuf == 0xFF ) {
        keySta = 0;
    } else {
        // 按键状态未稳定，不用处理
    }

}


void main()
{   
    // lastSta 存储上次按键状态
    bit lastSta = 0;  // 初值为未按下
    u8 cnt = 0;  // 记录按键按下次数

    timer_init();

    while (1) {
        // 用这种方式替代 while( key1 != 0 ) 松手检测
        if ( keySta != lastSta ) {  // 按键有动作
            if ( keySta == 1 ) {  // 按下
                cnt++; 
                if ( cnt > 10 ) {
                    cnt = 0; 
                } 
            }
        }
        lastSta = keySta;  // 更新历史值
    }
}

```